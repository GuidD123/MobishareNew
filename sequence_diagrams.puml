@startuml Mobishare_Sequence_Diagrams

skinparam sequenceBoxBorderColor #444
skinparam sequenceGroupBorderColor #777

' ========================================
' SCENARIO 1: AVVIO CORSA COMPLETO
' ========================================

title Scenario 1: Avvio Corsa BE002 - Flusso Completo con Retry Logic

actor Utente as U1
participant "WebApp\n(Razor Pages)" as WEB1
participant "API\n(CorseController)" as API1
participant "MobishareDbContext\n(EF Core)" as DB1
participant "MqttIoTService" as MQTT1
participant "MQTT Broker\n(Mosquitto)" as BROKER1
participant "IoT Gateway\n(MqttGatewayEmulatorService)" as IOT1
participant "SignalR Hub\n(NotificheHub)" as SIGNALR1
participant "PhilipsHueControl" as HUE1

U1 -> WEB1: Click su "Prenota" BE002
activate WEB1

WEB1 -> API1: POST /api/corse/inizia\n{ matricolaMezzo: "BE002", idParcheggioPrelievo: 1 }
activate API1

note right of API1
  **RETRY LOOP (MAX 5 tentativi)**
  Exponential backoff: 200ms, 500ms, 1s, 2s, 4s
  Gestisce DbUpdateConcurrencyException
end note

loop Retry tentativo 1-5
  
  API1 -> DB1: BEGIN TRANSACTION\n(Default IsolationLevel)
  activate DB1
  
  API1 -> DB1: FindAsync(idUtente) ‚Üí Carica Utente
  DB1 --> API1: Utente trovato (Credito: ‚Ç¨10.50)
  
  API1 -> DB1: AnyAsync(Corsa InCorso) ‚Üí Verifica corsa attiva
  DB1 --> API1: Nessuna corsa attiva
  
  alt PuntiBonus >= 10
    API1 -> DB1: Utente.Credito += 1.00‚Ç¨\nUtente.PuntiBonus -= 10
    DB1 --> API1: Credito aggiornato (in memoria)
    
    API1 -> SIGNALR1: Clients.Group("utenti:{id}")\n.SendAsync("BonusUsato")
    activate SIGNALR1
    SIGNALR1 -> U1: üéâ Notifica real-time\n"Hai utilizzato 10 punti!"
    deactivate SIGNALR1
    
    API1 -> DB1: SaveChangesAsync()
    DB1 --> API1: ‚úÖ Bonus salvato
  end
  
  API1 -> DB1: FindAsync(idParcheggio) ‚Üí Carica Parcheggio
  DB1 --> API1: Parcheggio trovato (Capienza: 10)
  
  API1 -> DB1: FirstOrDefaultAsync(Mezzo)\n+ WITH TRACKING ‚Üí Carica RowVersion
  DB1 --> API1: Mezzo BE002\n(Stato: Disponibile, RowVersion: 0x123ABC)
  
  API1 -> API1: Verifica Credito >= 0.50‚Ç¨
  API1 -> API1: Verifica Stato == Disponibile
  
  API1 -> DB1: Mezzo.Stato = InUso
  DB1 --> API1: Stato modificato (in memoria)
  
  API1 -> DB1: Corse.Add(nuovaCorsa)
  DB1 --> API1: Corsa aggiunta (in memoria)
  
  API1 -> DB1: SaveChangesAsync()\n‚Üí EF verifica RowVersion automaticamente
  
  alt RowVersion Match (Nessuna Race Condition)
    DB1 --> API1: ‚úÖ Salvato\n(Id=42, nuovo RowVersion: 0x124DEF)
    
    API1 -> MQTT1: SbloccaMezzoAsync(1, "BE002", userId)
    activate MQTT1
    
    MQTT1 -> BROKER1: PUBLISH Parking/1/Comandi/BE002\n{ comando: "Sblocca", commandId: "...", userId: "5" }
    activate BROKER1
    BROKER1 --> MQTT1: ACK
    deactivate BROKER1
    
    note over API1, MQTT1
      **Timeout 5 secondi**
      Task.WhenAny(mqttTask, Delay(5s))
    end note
    
    alt MQTT Risponde entro 5s
      MQTT1 --> API1: ‚úÖ Comando inviato
      deactivate MQTT1
      
      BROKER1 -> IOT1: MQTT Message ricevuto
      activate IOT1
      
      IOT1 -> IOT1: ProcessaSbloccoAsync()\n+ Avvia thread batteria
      
      IOT1 -> BROKER1: PUBLISH Parking/1/Mezzi/BE002\n{ batteria: 81, stato: "InUso" }
      activate BROKER1
      BROKER1 --> IOT1: ACK
      deactivate BROKER1
      
      IOT1 -> BROKER1: PUBLISH Parking/1/RisposteComandi/BE002\n{ successo: true }
      activate BROKER1
      BROKER1 --> IOT1: ACK
      deactivate BROKER1
      deactivate IOT1
      
      API1 -> DB1: COMMIT TRANSACTION ‚úÖ
      deactivate DB1
      
      API1 -> SIGNALR1: Clients.Group("admin")\n.SendAsync("NotificaAdmin")
      activate SIGNALR1
      SIGNALR1 -> SIGNALR1: Broadcast a admin\n"Nuova Corsa Iniziata"
      deactivate SIGNALR1
      
      API1 -> HUE1: SetSpiaColor("BE002", Blu)
      activate HUE1
      HUE1 -> HUE1: PUT /api/newdeveloper/lights/1/state\n{"on":true, "hue":46920, "sat":254, "bri":254}
      HUE1 --> API1: ‚úÖ Luce BLU attivata
      deactivate HUE1
      
      API1 --> WEB1: 201 Created\n{ id: 42, matricola: "BE002", ... }
      deactivate API1
      
      WEB1 --> U1: Redirect ‚Üí /Corse/CorsaCorrente
      deactivate WEB1
      
    else MQTT Timeout (> 5s)
      MQTT1 --> API1: ‚ùå Timeout
      deactivate MQTT1
      
      API1 -> DB1: ROLLBACK TRANSACTION ‚ùå
      deactivate DB1
      
      API1 --> WEB1: 400 Bad Request\n"Timeout: sistema IoT non risponde"
      deactivate API1
      
      WEB1 --> U1: Alert errore
      deactivate WEB1
    end
    
  else RowVersion Mismatch (Race Condition!)
    DB1 --> API1: ‚ùå DbUpdateConcurrencyException\n(Mezzo modificato da altro processo)
    
    API1 -> DB1: ROLLBACK TRANSACTION
    deactivate DB1
    
    API1 -> API1: EntityState.Detached\n(pulisce context)
    
    alt Tentativo < 5
      API1 -> API1: Delay(200ms, 500ms, 1s, 2s, 4s)
      note right: Loop continua ‚Üí Retry
    else Tentativo == 5
      API1 --> WEB1: 409 Conflict\n"Mezzo molto richiesto, riprova"
      deactivate API1
      WEB1 --> U1: Alert "Scegli altro mezzo"
      deactivate WEB1
    end
  end
  
end

note over API1, DB1
  **GESTIONE CONCORRENZA OTTIMISTICA**
  ‚Ä¢ Mezzo.RowVersion verificato automaticamente
  ‚Ä¢ Fino a 5 retry con exponential backoff
  ‚Ä¢ Race condition trasparente per l'utente
  
  **ORDINE OPERAZIONI CRITICO**
  1Ô∏è‚É£ BEGIN ‚Üí 2Ô∏è‚É£ SaveChanges ‚Üí 3Ô∏è‚É£ MQTT (wait 5s)
  4Ô∏è‚É£ COMMIT ‚Üí 5Ô∏è‚É£ SignalR ‚Üí 6Ô∏è‚É£ Philips Hue
end note

note right of IOT1
  Il Gateway IoT emula il dispositivo
  hardware sul mezzo e inizia a simulare
  la scarica della batteria durante la corsa.
  
  **TELEMETRIA**: I messaggi vengono pubblicati
  ogni 10s e consumati da MqttIoTBackgroundService,
  che aggiorna il DB e inoltra via SignalR.
  
  Il Gateway invia anche una risposta al comando
  su topic Parking/{id}/RisposteComandi/{id}.
end note

@enduml

' ========================================
' SCENARIO 2: TERMINAZIONE CORSA COMPLETA
' ========================================

@startuml Mobishare_Ride_Termination

title Scenario 2: Terminazione Corsa BE002 - Flusso Completo con Calcolo Costo

participant "Utente" as U3
participant "WebApp\n(Razor Pages)" as WEB3
participant "API\n(CorseController)" as API3
participant "MobishareDbContext\n(EF Core)" as DB3
participant "PagamentoService" as PAY3
participant "MqttIoTService" as MQTT3
participant "MQTT Broker" as BROKER3
participant "IoT Gateway" as IOT3
participant "SignalR Hub" as SIGNALR3
participant "PhilipsHueControl" as HUE3

U3 -> WEB3: Click "Termina Corsa"\n(Seleziona Parcheggio P2)
activate WEB3

WEB3 -> API3: PUT /api/corse/42\n{ idParcheggioRilascio: 2, dataOraFineCorsa: now }
activate API3

API3 -> DB3: BEGIN TRANSACTION\n(IsolationLevel.ReadCommitted)
activate DB3

API3 -> DB3: FirstOrDefaultAsync(Corsa)\n+ WITH TRACKING ‚Üí Carica RowVersion
DB3 --> API3: Corsa 42 trovata\n(Stato: InCorso, DataOraFine: null)

API3 -> API3: Verifica DataOraFine == null
note right: Se gi√† terminata ‚Üí Exception

API3 -> DB3: Corsa.DataOraFine = now\nCorsa.IdParcheggioRilascio = 2
DB3 --> API3: Modificato (in memoria)

API3 -> DB3: FindAsync(idUtente)
DB3 --> API3: Utente trovato (Credito: ‚Ç¨11.50)

API3 -> DB3: FirstOrDefaultAsync(Mezzo)
DB3 --> API3: Mezzo BE002\n(Tipo: BiciElettrica, Batteria: 81%)

API3 -> API3: Calcola durata corsa\ndurata = DataOraFine - DataOraInizio\n= 75 minuti

API3 -> API3: Calcola costo\n‚Ä¢ Base: 0.50‚Ç¨ (primi 30 min)\n‚Ä¢ Extra: 45 min √ó 0.20‚Ç¨/min = 9.00‚Ç¨\n‚Ä¢ Totale: 9.50‚Ç¨

API3 -> DB3: Corsa.CostoFinale = 9.50‚Ç¨\nCorsa.Stato = Completata
DB3 --> API3: Modificato (in memoria)

alt Tipo == BiciMuscolare
  API3 -> API3: Calcola punti bonus\npunti = durata / 30 min
  
  API3 -> DB3: Utente.PuntiBonus += punti
  DB3 --> API3: Punti aggiornati
  
  API3 -> SIGNALR3: Clients.Group("utenti:{id}")\n.SendAsync("BonusApplicato")
  activate SIGNALR3
  SIGNALR3 -> U3: üéâ Notifica real-time\n"Hai guadagnato X punti!"
  deactivate SIGNALR3
end

alt Mezzo elettrico
  API3 -> API3: Simula consumo batteria\nconsumo = durata / 6 min per 1%\n= 75/6 ‚âà 13%
  
  API3 -> DB3: Mezzo.LivelloBatteria -= 13%\n‚Üí Batteria: 68%
  DB3 --> API3: Batteria aggiornata
  
  alt Batteria < 20%
    API3 -> DB3: Mezzo.Stato = NonPrelevabile\nMezzo.MotivoNonPrelevabile = BatteriaScarica
    DB3 --> API3: Stato aggiornato
  end
end

alt SegnalazioneProblema == true
  API3 -> DB3: Mezzo.Stato = NonPrelevabile\nMezzo.MotivoNonPrelevabile = Guasto
  DB3 --> API3: Stato aggiornato
else Nessun problema
  API3 -> DB3: Mezzo.Stato = Disponibile\nMezzo.IdParcheggioCorrente = 2
  DB3 --> API3: Mezzo disponibile in P2
end

API3 -> DB3: SaveChangesAsync()
DB3 --> API3: ‚úÖ Salvato (verifica RowVersion OK)

API3 -> PAY3: RegistraMovimentoAsync()\n(userId, -9.50‚Ç¨, "Corsa", corsaId)
activate PAY3

PAY3 -> DB3: Crea Pagamento\n(Tipo: Debito, Importo: 9.50‚Ç¨, Stato: Completato)
DB3 --> PAY3: Pagamento salvato (Id=87)

PAY3 -> DB3: Utente.Credito -= 9.50‚Ç¨
DB3 --> PAY3: Nuovo credito: 2.00‚Ç¨

PAY3 -> DB3: SaveChangesAsync()
DB3 --> PAY3: ‚úÖ Salvato

deactivate PAY3

alt Credito < 0
  API3 -> DB3: Utente.Sospeso = true\nUtente.DebitoResiduo = |credito|
  DB3 --> API3: Utente sospeso
  
  API3 -> SIGNALR3: Clients.Group("utenti:{id}")\n.SendAsync("UtenteBloccato")
  activate SIGNALR3
  SIGNALR3 -> U3: ‚ö†Ô∏è "Account sospeso per debito"
  deactivate SIGNALR3
end

API3 -> MQTT3: BloccaMezzoAsync(2, "BE002")
activate MQTT3

MQTT3 -> BROKER3: PUBLISH Parking/2/Comandi/BE002\n{ comando: "Blocca" }
activate BROKER3
BROKER3 --> MQTT3: ACK
deactivate BROKER3

note over MQTT3
  **MQTT non bloccante**
  Se fallisce, la corsa viene
  comunque terminata (fail-safe)
end note

deactivate MQTT3

BROKER3 -> IOT3: MQTT Message ricevuto
activate IOT3

IOT3 -> IOT3: ProcessaBloccoAsync()\n+ Ferma thread batteria

IOT3 -> BROKER3: PUBLISH Parking/2/Mezzi/BE002\n{ batteria: 68, stato: "Disponibile" }
activate BROKER3
BROKER3 --> IOT3: ACK
deactivate BROKER3

IOT3 -> BROKER3: PUBLISH Parking/2/RisposteComandi/BE002\n{ successo: true }
activate BROKER3
BROKER3 --> IOT3: ACK
deactivate BROKER3
deactivate IOT3

API3 -> DB3: COMMIT TRANSACTION ‚úÖ
deactivate DB3

API3 -> PAY3: InviaNotificheMovimentoAsync()\n(userId, credito, -9.50‚Ç¨, "Corsa")
activate PAY3

PAY3 -> SIGNALR3: Clients.Group("utenti:{id}")\n.SendAsync("CreditoAggiornato", 2.00)
activate SIGNALR3
SIGNALR3 -> U3: üí∞ Credito aggiornato: 2.00‚Ç¨
deactivate SIGNALR3

PAY3 -> SIGNALR3: Clients.Group("utenti:{id}")\n.SendAsync("NuovaTransazione")
activate SIGNALR3
SIGNALR3 -> U3: üìã Transazione: -9.50‚Ç¨ (Corsa)
deactivate SIGNALR3

deactivate PAY3

API3 -> HUE3: SetSpiaColor("BE002", Verde/Rosso)
activate HUE3

alt Mezzo Disponibile
  HUE3 -> HUE3: PUT /api/newdeveloper/lights/1/state\n{"hue": 25500} ‚Üí VERDE
else Mezzo NonPrelevabile
  HUE3 -> HUE3: PUT /api/newdeveloper/lights/1/state\n{"hue": 0} ‚Üí ROSSO
end

HUE3 --> API3: ‚úÖ Colore aggiornato
deactivate HUE3

API3 -> SIGNALR3: Clients.Group("admin")\n.SendAsync("NotificaAdmin")
activate SIGNALR3
SIGNALR3 -> SIGNALR3: "Corsa terminata: 9.50‚Ç¨"
deactivate SIGNALR3

alt SegnalazioneProblema == true
  API3 -> SIGNALR3: Clients.Group("admin")\n.SendAsync("NotificaAdmin")
  activate SIGNALR3
  SIGNALR3 -> SIGNALR3: ‚ö†Ô∏è "Mezzo BE002 segnalato guasto"
  deactivate SIGNALR3
end

alt Batteria < 20%
  API3 -> SIGNALR3: Clients.Group("admin")\n.SendAsync("NotificaAdmin")
  activate SIGNALR3
  SIGNALR3 -> SIGNALR3: üîã "Batteria critica: 15%"
  deactivate SIGNALR3
end

API3 --> WEB3: 200 OK\n{ id: 42, costoFinale: 9.50, nuovoCredito: 2.00 }
deactivate API3

WEB3 --> U3: Redirect ‚Üí /Corse/Riepilogo/42
deactivate WEB3

note over API3, DB3
  **ORDINE OPERAZIONI TRANSAZIONALI**
  
  1Ô∏è‚É£ BEGIN TRANSACTION
  2Ô∏è‚É£ Aggiorna Corsa + Mezzo (calcolo costo, batteria)
  3Ô∏è‚É£ SaveChangesAsync() ‚Üí Verifica RowVersion
  4Ô∏è‚É£ RegistraMovimentoAsync() ‚Üí Pagamento + Credito
  5Ô∏è‚É£ BloccaMezzoAsync() ‚Üí MQTT (non bloccante)
  6Ô∏è‚É£ COMMIT TRANSACTION
  
  **POST-COMMIT (garantita consistenza)**
  7Ô∏è‚É£ InviaNotificheMovimentoAsync() ‚Üí SignalR utente
  8Ô∏è‚É£ SetSpiaColor() ‚Üí Philips Hue
  9Ô∏è‚É£ NotificaAdmin ‚Üí SignalR admin
  
  **Fail-safe**: MQTT pu√≤ fallire senza rollback
end note

@enduml

' ================================================================================
' SCENARIO 3: Aggiornamento Telemetria Mezzo (Background)
' ================================================================================

@startuml Scenario3_AggiornamentoTelemetria
title Scenario 3: Telemetria BE002 via MQTT - Flusso Completo Background

participant "IoT Gateway\n(Thread Batteria)" as IOT2
participant "MQTT Broker" as BROKER2
participant "MqttIoTService\n(Sottoscritto a Parking/+/Mezzi/#)" as MQTT2
participant "MqttIoTBackgroundService\n(Event Consumer)" as BG2
participant "MobishareDbContext\n(Scoped)" as DB2
participant "SignalR Hub" as SIGNALR2
participant "WebApp\n(Client JavaScript)" as WEB2

activate IOT2

note over IOT2
  **Thread attivo durante corsa**
  ProcessaSbloccoAsync() ha avviato
  Task.Run(() => SimulaBatteria())
  
  Consuma batteria ogni 10 secondi:
  ‚Ä¢ MonopattinoElettrico: 1-2% ogni 10s
  ‚Ä¢ BiciElettrica: 1% ogni 10s
  ‚Ä¢ BiciMuscolare: N/A (no batteria)
end note

loop Ogni 10 secondi (finch√© Stato == InUso)
  
  IOT2 -> IOT2: Calcola consumo batteria\nconsumo = random(1, 3) per monopattino\nconsumo = 1 per bici elettrica
  
  IOT2 -> IOT2: batteria -= consumo\nBatteria: 81% ‚Üí 79% ‚Üí 77%...
  
  alt Batteria < 20%
    IOT2 -> IOT2: Mezzo.Stato = NonPrelevabile\nMezzo.ColoreSpia = Rosso
    note right: Batteria critica ‚Üí Mezzo bloccato
  end
  
  IOT2 -> BROKER2: PUBLISH\nParking/1/Mezzi/BE002\n{ matricola: "BE002", stato: "InUso",\n  livelloBatteria: 77, timestamp: now }
  activate BROKER2
  BROKER2 --> IOT2: ACK
  deactivate BROKER2
  
  IOT2 -> IOT2: await Task.Delay(10s)
  
end

BROKER2 -> MQTT2: MQTT Message\nTopic: Parking/1/Mezzi/BE002
activate MQTT2

MQTT2 -> MQTT2: Deserializza payload\n‚Üí MezzoStatusMessage

MQTT2 -> MQTT2: Raise Event:\nMezzoStatusReceived(MezzoStatusReceivedEventArgs)
note right: Event-driven pattern

MQTT2 -> BG2: OnMezzoStatusReceived(sender, eventArgs)
activate BG2
deactivate MQTT2

BG2 -> BG2: Task.Run(() => HandleMezzoStatusAsync())\nEsegue in background (non blocca thread evento)

BG2 -> BG2: CreateScope() ‚Üí Ottieni DbContext scoped
activate DB2

BG2 -> DB2: FirstOrDefaultAsync(Mezzo)\nWHERE Matricola = 'BE002'
DB2 --> BG2: Mezzo trovato

alt Tipo == BiciMuscolare
  BG2 -> BG2: Aggiorna SOLO Stato\n(LivelloBatteria = null, forzato)
  note right: Bici muscolari NON hanno batteria
else Tipo elettrico (Bici/Monopattino)
  
  BG2 -> BG2: Verifica se cambiato\nbatteriaChanged = (db.Batteria != mqtt.Batteria)\nstatoChanged = (db.Stato != mqtt.Stato)
  
  alt Nessun cambiamento
    BG2 -> BG2: Skip update\n(ottimizzazione)
    note right: Evita write inutili
  else Cambio rilevato
    
    alt DB: Disponibile && MQTT: InUso
      BG2 -> BG2: Ignora aggiornamento\n(conflitto di stato)
      note right
        Caso edge: Gateway dice InUso
        ma DB dice gi√† Disponibile
        (corsa terminata nel frattempo)
      end note
    else Aggiornamento valido
      BG2 -> DB2: UPDATE Mezzi\nSET Stato = 'InUso',\n    LivelloBatteria = 77\nWHERE Matricola = 'BE002'
      DB2 --> BG2: ‚úÖ Salvato
    end
    
  end
end

BG2 -> DB2: SaveChangesAsync()
deactivate DB2

BG2 -> SIGNALR2: Clients.All.SendAsync("AggiornamentoTelemetria")\n{ matricola, stato, batteria, idParcheggio, timestamp }
activate SIGNALR2

SIGNALR2 -> WEB2: SignalR real-time push
activate WEB2
WEB2 -> WEB2: JavaScript riceve evento\nAggiorna UI dashboard admin\n(tabella mezzi, mappa, grafici)
deactivate WEB2

deactivate SIGNALR2
deactivate BG2

note over BG2, SIGNALR2
  **PATTERN EVENT-DRIVEN**
  
  1. MqttIoTService riceve MQTT ‚Üí Raise event
  2. MqttIoTBackgroundService sottoscritto
  3. Handler eseguito in Task.Run (async)
  4. Scope creato per DbContext isolato
  5. DB aggiornato + SignalR broadcast
  
  **OTTIMIZZAZIONI**
  ‚Ä¢ Skip update se nessun cambiamento
  ‚Ä¢ Filtra bici muscolari (no batteria)
  ‚Ä¢ Ignora conflitti stato (safety)
end note

@enduml

' ========================================
' SCENARIO 4: SINCRONIZZAZIONE GATEWAY CON DB
' ========================================

@startuml Mobishare_Gateway_Sync

title Scenario 4: Sincronizzazione Periodica Gateway - Flusso Completo

participant "GatewaySyncBackgroundService\n(Timer ogni 20s)" as SYNC
participant "MqttGatewayManager" as MGR
participant "MobishareDbContext\n(Scoped)" as DB
participant "Gateway P1\n(MqttGatewayEmulatorService)" as G1
participant "Gateway P2\n(MqttGatewayEmulatorService)" as G2

activate SYNC

SYNC -> SYNC: await Task.Delay(20s)\nTimer tick

SYNC -> MGR: SincronizzaMezziConDatabaseAsync()
activate MGR

note over MGR
  **Sincronizzazione per OGNI parcheggio**
  Itera tutti i gateway registrati
  (P1, P2, P3, P4, P5)
end note

loop Per ogni parcheggio (P1, P2, ...)

  MGR -> MGR: CreateScope() ‚Üí DbContext isolato
  activate DB
  
  MGR -> DB: SELECT Matricola, Tipo, Stato, LivelloBatteria\nFROM Mezzi\nWHERE IdParcheggioCorrente = 1
  DB --> MGR: Lista mezzi DB\n(BE002, ME003, BM004)
  
  MGR -> G1: GetMezziEmulati()
  activate G1
  G1 --> MGR: Lista mezzi in memoria\n(BE002, ME003, BM004, ME999)
  deactivate G1
  
  MGR -> MGR: Calcola differenze:\n‚Ä¢ daRimuovere = emulati - db\n‚Ä¢ daAggiungere = db - emulati
  
  alt Mezzi da rimuovere
    
    loop Per ogni matricola da rimuovere (ME999)
      
      MGR -> DB: FirstOrDefaultAsync(Mezzo)\nWHERE Matricola = 'ME999'
      DB --> MGR: Mezzo trovato\n(Stato: Disponibile, IdParcheggio: 2)
      
      alt Mezzo.Stato == InUso
        MGR -> MGR: ‚ö†Ô∏è Skip rimozione\n(corsa attiva, mezzo in transito)
        note right
          **FIX CRITICO**
          NON rimuovere mezzi InUso
          durante sync automatica
          (evita errori "Mezzo non trovato")
        end note
      else Mezzo.Stato != InUso
        MGR -> G1: RimuoviMezzoEmulato("ME999")
        activate G1
        
        G1 -> G1: _mezziEmulati.TryRemove("ME999")
        G1 -> G1: Ferma thread batteria\nCancelToken.Cancel()
        G1 -> G1: _batterySimulations.TryRemove()
        
        G1 --> MGR: ‚úÖ Mezzo rimosso
        deactivate G1
        
        note right: Mezzo spostato in altro parcheggio
      end
      
    end
    
  end
  
  alt Mezzi da aggiungere
    
    loop Per ogni matricola da aggiungere (BE005)
      
      MGR -> G1: AggiungiMezzoEmulato()\n(idMezzo, matricola, tipo, stato, batteria)
      activate G1
      
      G1 -> G1: MezzoEmulato creato\n_mezziEmulati.TryAdd("BE005", mezzo)
      G1 -> G1: ColoreSpia = Verde/Rosso/Giallo\n(in base a Stato)
      
      G1 --> MGR: ‚úÖ Mezzo aggiunto
      deactivate G1
      
      note right: Nuovo mezzo registrato in P1
      
    end
    
  end
  
  alt Nessuna modifica
    MGR -> MGR: Log: "Parcheggio {id}: nessuna modifica"
    note right: Ottimizzazione logging
  end
  
  deactivate DB
  
end

MGR --> SYNC: Sincronizzazione completata\n(5 gateway processati)
deactivate MGR

SYNC -> SYNC: await Task.Delay(20s)\nProssimo ciclo

deactivate SYNC

note over SYNC, MGR
  **LOGICA SINCRONIZZAZIONE**
  
  **Rimozione Mezzi:**
  ‚Ä¢ Mezzo non pi√π nel DB ‚Üí Rimuovi da Gateway
  ‚Ä¢ Mezzo spostato altro parcheggio ‚Üí Rimuovi
  ‚Ä¢ ‚ö†Ô∏è Mezzo InUso ‚Üí SKIP (fix race condition)
  
  **Aggiunta Mezzi:**
  ‚Ä¢ Mezzo nuovo in DB ‚Üí Aggiungi a Gateway
  ‚Ä¢ Mezzo arrivato da altro parcheggio ‚Üí Aggiungi
  
  **Ottimizzazioni:**
  ‚Ä¢ Scope isolato per ogni parcheggio
  ‚Ä¢ Logging condizionale (solo se modifiche)
  ‚Ä¢ Catch errors per parcheggio singolo
    (non blocca sync altri parcheggi)
end note

@enduml
