DOCUMENTAZIONE UTILE RAZOR PAGES 

Razor pages è un modello di sviluppo web server-side basato su pagine singole invece di controller multipli
Ogni pagina ha:

	un file .cshtml -> è la vista (HTML + codice Razor)
	un file .cshtml.cs -> è il PageModel (codice C# che gestisce logica, input e output)

		es: /Pages/Corse/Index.cshtml
			/Pages/Corse/Index.cshtml.cs

Funzionamento!!

	Quando utente apre /Corse/Index il framework esegue il metodo OnGet() nel file Index.cshtml.cs e questo metodo prepara i dati da mostrare, la vista (Index.cshtml) usa il modello @model IndexModel per accedere ai dati 


// Index.cshtml.cs
public class IndexModel : PageModel
{
    public List<string> Corse { get; set; } = new();

    public void OnGet()
    {
        Corse = ["Bici 1", "Monopattino 2", "Bici 3"];
    }
}

<!-- Index.cshtml -->
@page
@model Mobishare.WebApp.Pages.Corse.IndexModel

<h2>Corse disponibili</h2>
<ul>
@foreach (var nome in Model.Corse)
{
    <li>@nome</li>
}
</ul>


Ciclo di vita:

Ogni pagina può rispondere a richieste HTTP con metodi:

OnGet()-> per richieste GET
OnPost() -> per form inviati con POST
OnPut(), OnDelete() -> per altri metodi 

    Posso anche avere versioni asincrone 

        Es: public async Task OngetAsync()
            public async Task<IActionResult> OnPostAsync()


PAGEMODEL -> cervello della pagina 
E' come un mini-controller dedicato a quella pagina 
Ha 3 scopi:

    Ricevere dati dal browser (binding)
    Eseguire logica e chiamate API
    Fornire dati alla vista

es: 
public class DettaglioMezzoModel : PageModel
{
    private readonly HttpClient _http;
    public MezzoDto? Mezzo { get; set; }

    public DettaglioMezzoModel(IHttpClientFactory factory)
    {
        _http = factory.CreateClient("MobishareApi");
    }

    public async Task OnGetAsync(string id)
    {
        Mezzo = await _http.GetFromJsonAsync<MezzoDto>($"api/mezzi/{id}");
    }
}


La vista .cshtml -> è HTML con sintassi Razor per integrare con C#
Principali direttive:
    
        @model -> collega classe PageModel
        @{ } -> blocco C#
        @if, @foreach, @Model.Proprietà -> logica inline

Es: 
@page
@model DettaglioMezzoModel

<h1>Dettagli mezzo</h1>

@if (Model.Mezzo is not null)
{
    <p>Codice: @Model.Mezzo.Id</p>
    <p>Stato: @Model.Mezzo.Stato</p>
}
else
{
    <p>Nessun mezzo trovato.</p>
}



Form e POST 
Posso inviare dati da un form HTML e riceverli nel metodo OnPost()

@page
@model RicaricaCreditoModel

<form method="post">
    <input type="number" asp-for="Importo" />
    <button type="submit">Ricarica</button>
</form>


public class RicaricaCreditoModel : PageModel
{
    [BindProperty]
    public decimal Importo { get; set; }

    public IActionResult OnPost()
    {
        if (Importo <= 0)
            return Page(); // Resta sulla pagina

        // Esegui ricarica
        return RedirectToPage("/Utenti/Profilo");
    }
}


COME SI COLLEGA AL BACKEND MOBISHARE 
Nel mio progetto WebApp Razor Pages è il frontend che dialoga con backend REST -> Mobishare.API

    Tramite HttpClient
    Usando Endpoint come    api/corse, api/mezzi ecc.....

Configurazione in Program.cs:
builder.Services.AddHttpClient("MobishareApi", client =>
{
    client.BaseAddress = new Uri("https://localhost:5001/");
});

Poi nel PageModel:
private readonly HttpClient _http;
public IndexModel(IHttpClientFactory factory)
{
    _http = factory.CreateClient("MobishareApi");
}



PARTIAL, LAYOUT E RIUSO 
    Razor Pages supporta layout e partial views: 

        _Layout.cshmtl è il template principale con navbar e footer
        _ValidationScriptsPartial.cshtml = script per validazione form